# 도커 컨테이너 배포

|도커이미지|도커 컨테이너|
|---|---|
|도커 컨테이너를 구성하는 파일 시스템과 실행할 애플리케이션 설정을 하나로 합친것으로,|도커이미지를 기반으로 생성되며,|
|컨테이너를 생성하는 템플릿 역할을 한다.|파일 시스템과 애플리케이션이 구체화 되어 실행되는 상태|


Dockerfile에 작성에 사용하는 `FROM`, `RUN` 과 같은 키워드를 인스트럭션(명령)이라고 한다.

CMD 인스트럭션을 사용할때는 명령을 공백으로 나눈 배열로 나타낸다.

ex)

```shell
$ npm run start
```

```dockerfile
CMD ["npm", "run", "start"]
```

물론 `CMD npm run start" 와 같이 작성 할 수 있지만, 인자 배열 방식을 권장한다.
[//]: # (TODO : 차이점과 권장하는 이유 확인할것)

### 도커이미지 빌드하기
`$ docker image build -t 이미지명[:태그명] Dockerfile_경로` 의 포맷을 사용하며,<br/>
-t 옵션으로 이미지명과 태그를 지정하는데 사용한다.

ex)
```shell
$ docker [image] build -t hodory/docker-starter:latest .
```

위와 같이 이미지명에는 일반적으로 Github Repo와 비슷하게 사용한다.

일반적으로는 Dockerfile이라는 이름으로 된 Dockerfile을 찾으나, `-f` 옵션을 사용하여 이름을 지정할 수 있다.

FROM 인스트럭션에 지정한 이미지를 레지스트리에서 받은 후 저장해두고 사용하나,<br/>
최신 버전이 로컬에 캐시된것과 다르게 바뀔 수 있기 때문에 `--pull=true` 옵션을 사용해서 빌드마다 매번 강제로 받을 수 있다.<br/>
이 방법은 빌드 속도면에서는 불리하다.  

### CMD 인스트럭션 작성 방법
`CMD ["실행 파일", "인자1", "인자2"]` : 실행 파일에 인자를 전달. 권장되는 사용 방식
`CMD 명령 인자1 인자2`: 명령과 인자를 지정. 셸에서 실행돼서 셸에 정의된 변수를 참조 할 수 있음
`CMD ["인자1", "인자2"]` :  ENTRYPOINT에 지정된 명령에 사용할 인자를 전달


### 도커 컨테이너 실행
```shell
$ docker [container] run example:echo:latest
```
이와 같이 실행하면 컨테이너가 포어그라운드에서 동작하므로, 종료 하기 위해 Ctrl+C를 입력해야한다.<br/>
데몬으로 실행하기 위해서는 -d 옵션을 붙여 백그라운드로 컨테이너를 실행한다.

`docker container ls` 명령을 이용해 현재 실행중인 도커 컨테이너 목록을 볼 수 있다.

#### 포트포워딩
도커 컨테이너는 가상 환경이지만, 외부에서 봤을때 독립된 하나의 머신처럼 다룰 수 있다는 특징이 있다.<br/>
애플리케이션이 8080 포트를 리스닝하게 설정해두었더라도, 컨테이너 안에서 cURL 명령으로는 응답을 받을 수 있지만,<br/> 
외부에서의 접근은 해당 포트를 바로 사용할 수 없다는 것이다.

컨테이너 밖에서 들어온 요청 포트를 컨테이너의 포트에 전달해주는 도커 포트 포워딩을 이용하여,<br/>
도커 외부에서도 컨테이너의 포트를 이용할 수 있게한다.

포트포워딩은 `-p {호스트의 포트}:{컨테이너의 포트}`와 같은 옵션을 주어 설정 할 수 있다.<br/>
예로 컨테이너의 8080 포트를 localhost:8082로 접근하기 위해서는 아래와 같은 커맨드를 실행하면 된다.
```shell
$ docker [container] run -p 8082:8080 example/echo:latest
```
이때 호스트의 포트를 생략 하면 임의의 빈 포트가 ephemeral 포트로 자동 할당된다.


### `docker image tag` : 이미지에 태그 붙이기

이미지 빌드를 하면 도커 이미지의 버전 넘버 역할을 하는 IMAGE ID 값이 변하게되어 매번 다른 이미지가 된다.<br/>
Dockerfile을 편집했을 때 뿐만 아니라 COPY 대상이 되는 파일의 내용이 바뀌어도 IMAGE ID 값이 바뀐다.
IMAGE ID는 git 커밋의 해시와 같이 볼 수 있다.

도커에서 태그 하나에 연결될 수 있는 이미지는 하나뿐이므로, `$ docker image ls`를 명령행에 입력 했을때<br/>
<none>으로 되어있는것들은 태그가 해제된 것들이다.

`$ docker image tag 베이스이미지명[:태그] 새이미지명[:태그]` 와 같은 명령 포맷을 가지며
예시로 `$ docker image tag example/echo:latest example/echo:0.1.0` 와 같이 명령행에 입력하면<br/>
`example/echo:latest` 이미지를 0.1.0 태그를 부여 한다.

### `docker image push` : 이미지를 외부에 공개하기
현재 저장된 도커 이미지를 도커 허브등의 레지스트리에 등록하기 위해 사용한다.<br/>
Github와 동일하게 도커 허브에서도 권한이 있는 리포지토리에만 이미지를 등록 할 수 있다.

포맷은 아래와 같다
```shell 
$ docker image push [options] 리포지토리명[:태그]`
```

## 도커 컨테이너 다루기

### 도커 컨테이너 LifeCycle
실행중, 정지, 파기 3가지 상태가 있다.

명령이 바로 실행되고 끝나는 명령행 도구 등의 컨테이너는 실행중 상태가 길게 유지되지 않고 정지상태가 된다.

#### 정지상태(stop)
컨테이너를 정지시키면 가상 환경으로서는 더 이상 동작하지 않지만, 디스크에 컨테이너가 종료되던 시점 상태가 저장돼 남아,<br/>
정지시킨 컨테이너를 다시 실행할 수 있다.

#### 파기상태
정지상태의 컨테이너를 명시적으로 삭제하지 않는 이상 그대로 디스크에 남아있기 때문에, 불필요한 컨테이너를 삭제하는것이 바람직하다.<br/>
하지만 한번 파기한 컨테이너는 다시 실행 할 수 없고, 완전히 정보가 같은 컨테이너를 만들 수는 없으므로 삭제에 유의해야한다.

### `docker container run` : 컨테이너 생성 및 실행
#### 실행방법
`$ docker container run [options] 이미지명[:태그] [명령] [명령인자...]`
또는
`$ docker container run [options] 이미지ID [명령] [명령인자...]`로 컨테이너를 생성하고 실행한다. 

#### 명령인자가 뭐지
명령인자로 CMD 인스트럭션을 오버라이드 할 수 있다.
`$ docker [container] run -it alpine:3.7`은 셸(/bin/sh)을 실행시키지만, `$ docker [container] run -it alpine:3.7 uname -a` 와 같이 CMD 명령을 바꿀 수 있다.

#### 컨테이너명 설정하기
컨테이너를 실행하면 무작위의 값으로 컨테이너명이 설정되는데, `--name` 옵션으로 이름을 지정할 수 있다.
ex)
```shell
$ docker container run -t -d --name latest-node-js node:latest`
```  
개발 환경에서는 비교적 자주 사용 되지만, 같은 이름을 지정할 수 없는 문제로 동일 이름의 기존의 컨테이너를 정지하고 삭제 해야하기 때문에,<br/>
운영환경에서는 적합하지 않아 거의 사용되지 않는다.

#### 또 다른 옵션들
1. `-i` : 컨테이너 쪽 표준 입력과의 연결을 그대로 유지. 셸에 들어가 명령을 실행할 수 있다. `-t` 와 함께 많이 쓰인다.
2. `-t` : 유사 터미널 기능을 활성화 하는 옵션.<br/>
 `-i` 옵션을 사용하지 않으면 입력을 할 수 없으므로 같이 사용하고 축약인 `-it`를 사용한다.
3. `--rm` : 컨테이너를 종료할 때 컨테이너를 파기하도록 하는 옵션. 명령행 도구 컨테이너 실행시 유용하다.
4. `-v` : 호스트와 컨테이너 간에 디렉터리나 파일을 공유 하기 위해 사용 (볼륨 마운팅이라고 한다) 

### `docker container ls` : 도커 컨테이너 목록 보기
기본 사용 방법은 이와 같다
```shell
$ docker container ls [options]
```

#### 컨테이너 ID만 추출하기

`-q` 옵션을 사용해 컨테이너 ID(축약형)만 추출할 수 있다.

#### 목록 필터링하기
```shell
$ docker container ls --filter "필터명=값"
```
이름으로 필터링을 하기위해서는 필터명에 `name`을 쓰고, 생성한 이미지를 기준으로 하려면 `ancestor`를 쓴다. 
ex)
```shell
# 이름으로 필터링
$ docker container ls --filter "name=myapp"

# 이미지 기준 필터링
$ docker container ls --filter "ancestor=node"
```

#### 종료된 컨테이너 목록 보기
컨테이너가 파기되지 않았다면 재시작이나 실행시점 `stdout`을 확인 하기위해 종료된 컨테이너의 목록에 보기 위해서는 `-a` 옵션을 사용하면된다.

#### 컨테이너를 정지할 때 함께 삭제하기
```docker container run` : 컨테이너 생성 및 실행`에서 언급되었지만,
명령행 도구로 사용할때 이용하면 유용하다.

나와 같은 경우에는 로컬에 개발에 필요한 항목들을 PC에 설치하는것을 선호하지 않아 docker를 사용하는 경우가 많은데,<br/>
항상 정지된 컨테이너를 직접 지워 줬는데 이게 많이 도움이 될 것 같다.

### `docker container logs` : 표준 출력(stdout) 연결하기
stdout으로 출력된 내용을 확인할 수 있다. 이것만 확인할 수 있으므로 파일등에 출력된 로그는 볼 수 없다.<br/>
쉽게 도커 컨테이너의 로그라고도 부른다.

`-f` 옵션을 사용하면 `tail -f`와 같이 새로 출력되는 내용을 계속 보여준다.

### `docker container exec` : 실행중인 컨테이너에서 명령 실행

ssh로 로그인한 것 처럼 컨테이너 내부를 조작할 수 있다.

위에 언급한것과 같이 stdin을 유지하는 -i 옵션과 유사터미널을 실행하는 -t옵션을 조합하면 셸을 통해 다룰 수 있다.
```shell
$ docker container exec [options] 컨테이너ID_또는_컨테이너명 컨테이너에서_실행할_명령
```

디버깅이나 내부 상태 확인을 위해 사용할 수 있으나, 파일을 수정하는것은 애플리케이션의 의도치 않은 부작용을 초래할 수 있으므로 운영에서는 금기된다.

### `docker container cp` : 파일 복사

COPY 인스트럭션은 이미지 빌드시에 정의하는것이지만, <br/>
실행중인 컨테이너와 파일을 주고받기위한 명령으로 사용한다.
```shell
$ docker container cp [options] 컨테이너ID_또는_컨테이너명:원본파일 대상파일

$ docker container cp [options 호스트_원본파일 컨테이너ID_또는_컨테이너명:대상파일]
```

아래와 같이 호스트에서 컨테이너로 파일을 복사 할 수도 있다.
```shell
$ docker container cp cummy.txt echo:/tmp
$ docker container exec echo ls /tmp | grep dummy
```
디버깅 중 컨테이너 안에서 생성된 파일을 호스트로 옮겨 확인할 목적으로 사용하는 경우가 대부분이다.
정지상태의 컨테이너에 대해서도 실행할 수 있다.

### TIPS
1. 일반적으로 `docker run` 이나 `docker pull` 과 같은 축약어를 많이 사용하나,<br/>
최근에는 `docker container run`과 같이 목적 대상과 의도가 명확한 명령을 사용하는것을 추천하고 있다. 
