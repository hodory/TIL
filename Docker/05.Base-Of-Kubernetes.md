# 쿠버네티스 입문

## 쿠버네티스란
컨테이너 운영을 자동화 하기 위한 커넽이너 오케스트레이션 도구.<br/>
많은 수의 컨테이너를 협조적으로 연동시키기 위한 통합 시스템으로, API 및 명령행 도구등이 함께 제공된다.

애플리케이션 배포 이외에도 다양한 운영 관리 업무를 자동화 할 수 있다.
- 도커 호스트 관리
- 서비스 리소스의 여유를 고려한 컨테이너 배치 및 스케일링
- 여러개 컨테이너 그룹에 대한 로드밸런싱 Health Check

## Kubectl
쿠버네티스를 다루기 위한 명령행 도구

kubernetes-dashboard를 이용하면 쿠버네티스에 관한 정보들을 쉽게 확인할 수 있다.

## MiniKube
Docker에 Kubernetes 연동 기능이 추가되기전까지 사용되던 minikube는 로컬에 dockerd를 새로 띄워 이를 대상으로 쿠버네티스 환경을 구축하였다.<br/>

dockerd가 2개이므로 다루기에 상대적으로 까다로운 단점이 있으나, 지원 플랫폼이 다양한 장점이 있다.(Win10 Pro 이하에서는 hyper-v 지원이 되지 않아 minikube를 사용할 수 밖에 없다.)

## 쿠버네티스 클러스터

여러 리소스를 관리하기 위한 집합체.

마스터와 노드의 그룹으로 구성되며,<br/>
쿠버네티스 클러스터 전체를 관리하는 서버인 마스터가 적어도 하나 이상 있어야한다.

클러스터에 배치된 노드의 수, 노드의 사양 등에 따라 배치할 수 있는 컨테이너의 수가 결정된다.

클라우드 플랫폼 상에서 GCP는 GCE가 AWS는 EC2 인스턴스가 노드가 된다.

## 마스터 서버의 컴포넌트
1. **kube-apiserver** : API를 노출. kubectl로부터 리소스를 조작하라는 지시를 받는다.
2. **etcd** : 고가용성 k-v 분산스토어로, 클러스터 백킹 스토어로 쓰인다.
3. **kube-scheduler** : 노드를 모니터링하고, 컨테이너 배치에 적절한 노드를 선택한다.
4. **kube-controller-manager** : 리소스를 제어하는 컨트롤러를 실행한다.

non-managed 환경에서 마스터 서버가 SPOF(Single Point Faliure: 단일 장애점. 시스템 구성 요소중 동작하지 않으면 전체 시스템이 중단되는 요소)가 되지 않도록 마스터를 3대 두는것이 일반적이다.

---

## 용어 정리
### Namespace
클러스터 안의 가상 클러스터

### Pod
컨테이너 하나 혹은 컨테이너의 집합체

nginx 컨테이너와 JAVA 애플리케이션 컨테이너와 같이 서로 강한 결합을 유지하는 경우 또는 함께 배포해야 정합성을 유지할 수 있는 컨테이너 등은 같은 Pod로 묶어 일괄 배포한다.<br/>
하나인 경우에도 Pod로 배포한다.

Pod는 노드에 배치되며 같은 Pod를 여러 노드에 둘수도 있고, 한 노드에 여러개의 Pod를 둘 수도 있다.

한 Pod안의 컨테이너는 모두 같은 노드에 배치해야한다.

마스터 노드에는 관리용 컴포넌트만 담긴 Pod가 배포되므로, 애플리케이션 파드를 배포할 수 없다.

### Manifest File
쿠버네티스 리소스 정의 파일.

배포시에 manifest 파일의 내용을 그대로 반영하려면 apply 명령을 사용할 때 `-f` 옵션으로 경로를 지정하면 된다.<br/>
ex)
```shell script
$ kubectl apply -f ./simple-pod.yaml
```

#### Kind
쿠버네티스 리소스 유형을 지정하는 속성.<br/>
값에 따라 Spec 아래의 스키마가 변화한다.

#### metadata
리소스에 부여되는 메타데이터

#### spec
리소스를 정의하기 위한 속성. 파드의 경우 파드를 구성하는 컨테이너를 `containers` 아래에 정의한다.

#### ports
컨테이너가 Expose 할 포트를 지정할 수 있으나, Dockerfile에서 지정했을 경우 따로 지정할 필요가 없다.


---

DockerSwarm은 Name Resolution을 이용해 이름으로 접근이 가능하나, 쿠버네티스는 localhost로 접근이 가능하다.

파드에 각가 고유의 가상 IP가 할당되고, 파드에 속하는 모든 컨테이너가 공유한다.

가상 IP로 다른 파드와 통신 할 수 있다.

## 레플리카 세트
매니페스트 파일로는 하나의 파드만 생성할 수 있으나, 똑같은 정의를 갖는 파드를 여러개 생성하고 관리하기 위한 리소스.

template 아래에 파드 리소스 정의를 하면된다.

정의에 따라 replicas에 지정한 수만큼 파드를 만들어 정의 및 복제를 수행하고,<br/>
파드명에 무작위 접미사가 붙는다.

삭제된 파드는 복원 불가능하므로 웹 애플리케이션 같은 Stateless 파드에 유리하다.

## 디플로이먼트
레플리카 세트를 관리하고 다루기 위한 리소스로 애플리케이션 배포의 기본 단위 리소스.

정의는 레플리카 세트와 크게 다르지 않으나, 레플리카 세트의 리비전 관리가 가능하며, 일반적으로 레플리카 세트보다 디플로이먼트를 다룬다.<br/>
디플로이먼트는 파드를 새로운 버전으로 교체하거나 이전 버전으로 롤백 하는 등의 중요 역할을 수행한다.

디플로이먼트는 리비전 번호가 기록되므로 특정 리비전의 내용을 확인 가능하다. `--revision={버전번호}`

### 동작방식
디플로이먼트를 수정 -> 레플리카세트가 새로 생성(리비전 번호가 증가됨) -> 기존레플리카 세트와 교체<br/>
=> 컨테이너 정의를 수정하거나 이미지를 변경하면 새 레플리카 세트가 생성되지만, 파드 개수 수정의 경우에는 리비전 번호의 변화가 없다.

## 서비스
서비스는 클러스터 안에서 파드의 집합(주로 레플리카 세트)에 대한 경로나,<br/>
서비스 디스커버리(API 주소가 동적으로 바뀌는 경우에도 클라이언트가 접속 대상을 바꾸지 않고, 하나의 이름으로 접속 가능하도록 하는 기능)를 제공하는 리소스

서비스 대상파드는 서비스에서 정의하는 레이블 셀렉터로 정해진다.


클러스터 안에 있는 애플리케이션끼리 연동 시킬때 서비스명만으로 네임레졸루션이 가능하며 대상파드로 요청 분산이 가능.

### 서비스네임 레졸루션
클러스터 DNS는 서비스명.네임스페이스명.svc.local로 연결해준다.<br/>
`svc.local` 부분은 생략할 수 있으며, 같은 네임스페이스는 서비스명 만으로 참조 가능하다.

서비스의 기본 종류는 clusterIP(내부 IP 주소에 서비스를 공개할 수 있고, 서비스명으로 네임레졸루션이 가능해지지만 외부로부터는 접근 불가능)이다.

### NodePort 서비스
클러스터 외부에서 접근할 수 있는 서비스

clusterIP를 만들지만 각 노드에서 서비스 포트로 접속하기위한 글로벌 포트를 개방(외부 접근이 가능해진다)

### Loadbalancer 서비스
로컬에서는 사용할 수 없고, 클라우드 플랫폼의 로드밸런서와 연동에 사용한다.

### ExternalName 서비스
클러스터에 외부호스트를 네임레졸루션 하기위한 별명을 제공하고, 셀렉터나 포트 정의가 없다.

---

## 명령어 정리

- 현재 클러스터에 소속된 노드의 목록 : `$ kubectl get nodes`
- 현재 클러스터 안에 존재하는 네임스페이스의 목록 조회 : `$ kubectl get namespace`
- **$ kubectl apply -f {manifest 파일 경로}** : 파일의 경로를 지정하여 `manifest`의 내용을 반영
- **$ kubectl get pod** : 파드정보를 조회. READY 필드는 {실행상태_컨테이너개수}/{파드에_정의된_컨테이너개수}
- **$ kubectl exec -it {파드명} sh -c {컨테이너명}** :  `docker container exec` 명령과 유사하나, 파드안의 컨테이너가 여러개인 경우 -c 옵션에 컨테이너 명을 지정한다.
- **$ kubectl logs** : stdout 로그 조회 (`docker container logs` 명령과 같다)
- **$ kubectl delete pod {파드명}** : 지정된 파드 삭제
- **$ kubectl delete -f {manifest 파일 경로}** : manifest 안에 작성된 리소스 전체가 삭제된다.
- **$ kubectl rollout history** : 디플로이먼트의 리비전 확인 가능.
- `--record` 옵션을 쓰면 kubectl 명령 실행 기록이 남길 수 있다.
- **$ kubectl rollout history deployment {디플로이먼트명}** : 해당 디플로이먼트의 리비전 조회 
- **$ kubectl rollout undo deployment {디플로이먼트명}** : 직전 리비전 롤백 가능
- **$ kubectl get svc {파드명}** : 해당 파드의 서비스를 조회 
